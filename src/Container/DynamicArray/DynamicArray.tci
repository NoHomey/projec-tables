#pragma once

#include "DynamicArray.htd"
#include <utility>
#include <type_traits>
#include <new>

template<typename Element>
DynamicArray<Element>::DynamicArray() noexcept
: array{nullptr}, arraySize{0}, arrayCapacity{0} {}

template<typename Element>
DynamicArray<Element>::DynamicArray(size_t size)
: DynamicArray{} {
    if(size > 0) {
        array = reinterpret_cast<Element*>(new char[size * sizeof(Element)]);
        for(size_t index = 0; index < size; ++index) {
            new (array + index) Element();
        }
        arrayCapacity = size;
    }
}

template<typename Element>
void DynamicArray<Element>::deAllocate() noexcept {
    for(size_t index = 0; index < arrayCapacity; ++index) {
        array[index].~Element();
    }
    delete[] reinterpret_cast<char*>(array);
}

template<typename Element>
DynamicArray<Element>::~DynamicArray() noexcept {
    deAllocate();
}

template<typename Element>
void DynamicArray<Element>::destroy() noexcept {
    array = nullptr;
    arraySize = 0;
    arrayCapacity = 0;
}

template<typename Element>
void DynamicArray<Element>::move(DynamicArray& other) noexcept {
    deAllocate();
    array = other.array;
    arraySize = other.arraySize;
    arrayCapacity = other.arrayCapacity;
    other.destroy();
}

template<typename Element>
DynamicArray<Element>::DynamicArray(DynamicArray&& other) noexcept
: DynamicArray{} {
    if(!other.isEmpty()) {
        move(other);       
    }
}

template<typename Element>
DynamicArray<Element>& DynamicArray<Element>::operator=(DynamicArray&& other) noexcept {
    if(this != &other) {
        if(other.arrayCapacity == 0) {
            clear();
        } else {
            move(other);
        }
    }
    return *this;
}

template<typename Element>
size_t DynamicArray<Element>::size() const noexcept {
    return arraySize;
}

template<typename Element>
size_t DynamicArray<Element>::capacity() const noexcept {
    return arrayCapacity;
}

template<typename Element>
size_t DynamicArray<Element>::unused() const noexcept {
    return arrayCapacity - arraySize;
}

template<typename Element>
bool DynamicArray<Element>::isEmpty() const noexcept {
    return arraySize == 0;
}

template<typename Element>
bool DynamicArray<Element>::isFull() const noexcept {
    return arraySize == arrayCapacity;
}

template<typename Element>
bool DynamicArray<Element>::hasElementAt(size_t index) const noexcept {
    return index < arraySize;
}

template<typename Element>
Element& DynamicArray<Element>::operator[](size_t index) noexcept {
    return array[index];
}

template<typename Element>
const Element& DynamicArray<Element>::operator[](size_t index) const noexcept {
    return array[index];
}

template<typename Element>
const Element& DynamicArray<Element>::getElement(size_t index) const noexcept {
    return array[index];
}

template<typename Element>
const Element* DynamicArray<Element>::data() const noexcept {
    return array;
}

template<typename Element>
void DynamicArray<Element>::ensureCapacity() {
    if(isFull()) {
        extend(arrayCapacity + 2);
    }
}

template<typename Element>
void DynamicArray<Element>::fill(size_t count) {
    if(count > 0) {
        ensureCapacity(count);
        arraySize += count;
    }
}

template<typename Element>
void DynamicArray<Element>::push(const Element& element) {
    ensureCapacity();
    array[arraySize] = element;
    ++arraySize;
}

template<typename Element>
void DynamicArray<Element>::movePush(Element&& element) {
    ensureCapacity();
    array[arraySize] = std::move(element);
    ++arraySize;
}

template<typename Element>
void DynamicArray<Element>::pop() noexcept {
    if(!isEmpty()) {
        --arraySize;
    }
}

template<typename Element>
void DynamicArray<Element>::pop(size_t count) noexcept {
    if(count >= arraySize) {
        arraySize = 0;
    } else {
        arraySize -= count;
    }
}

template<typename Element>
void DynamicArray<Element>::empty() noexcept {
    arraySize = 0;
}

template<typename Element>
void DynamicArray<Element>::setElement(size_t index, Element&& element) {
    if(hasElementAt(index)) {
        array[index] = std::forward(element);
    } else if(index == arraySize) {
        push(std::forward(element));
    }
}

template<typename Element>
void MoveHelper<Element, true>::moveElement(Element* dest, Element* source, size_t index) {
    new (dest + index) Element(std::move(source[index]));
}

template<typename Element>
void MoveHelper<Element, false>::moveElement(Element* dest, Element* source, size_t index) {
    new (dest + index) Element(source[index]);
    source[index].~Element();
}

template<typename Element>
void DynamicArray<Element>::changeCapacity(size_t capacity) {
    if(capacity >= arraySize) {
        Element* temp = reinterpret_cast<Element*>(new char[capacity * sizeof(Element)]);
        for(size_t index = 0; index < capacity; ++index) {
            if(index < arraySize) {
                MoveHelper<Element, std::is_nothrow_move_constructible<Element>::value>::moveElement(temp, array, index);
            } else {
                new (temp + index) Element();
            }
        }
        for(size_t index = arraySize; index < arrayCapacity; ++index) {
            array[index].~Element();
        }
        delete[] reinterpret_cast<char*>(array);
        array = temp;
        arrayCapacity = capacity; 
    }
}

template<typename Element>
void DynamicArray<Element>::extend(size_t size) {
    if(size > 0) {
        changeCapacity(arrayCapacity + size);
    }
}

template<typename Element>
void DynamicArray<Element>::ensureCapacity(size_t capacity) {
    const size_t unusedCount = unused();
    if(unusedCount < capacity) {
        extend(capacity - unusedCount);
    }
}

template<typename Element>
void DynamicArray<Element>::shrinkToFit() {
    if(!isFull()) {
        changeCapacity(arraySize);
    }
}

template<typename Element>
void DynamicArray<Element>::clear() noexcept {
    if(arrayCapacity > 0) {
        deAllocate();
        destroy();
    }
}

template<typename Element>
template<typename ForEachInDynamicArrayFunction>
void DynamicArray<Element>::forEachElement(ForEachInDynamicArrayFunction function) const {
    for(size_t index = 0; hasElementAt(index); ++index) {
        function(array[index], index);
    }
}

template<typename Element>
template<typename ForEachInDynamicArrayFunction>
void DynamicArray<Element>::forEach(ForEachInDynamicArrayFunction& function) const {
    forEachElement<ForEachInDynamicArrayFunction&>(function);
}

template<typename Element>
template<typename ForEachInDynamicArrayFunction>
void DynamicArray<Element>::forEach(const ForEachInDynamicArrayFunction& function) const {
    forEachElement<const ForEachInDynamicArrayFunction&>(function);
}